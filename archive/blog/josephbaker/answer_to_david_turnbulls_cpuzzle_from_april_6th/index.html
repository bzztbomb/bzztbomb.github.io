<p>David's puzzle on April 6th was a lot of fun to work with. &nbsp;If you want to see my answer, read the first few pages of:</p><p><a href="http://joseph-baker.com/DorkBotCPuzzleOverview.pdf">http://joseph-baker.com/DorkBotCPuzzleOverview.pdf</a></p><div>My answer to David’s puzzle is:</div><div>This snippet of code coverts information from one encoding into a more intuitive&nbsp;</div><div>encoding that includes error detection.</div><div>&nbsp;</div><div>Input Encoding:</div><div>This program receives information encoded in the following token format:</div><div>1. ‘3’ is a binary 1</div><div>2. ‘1’ is a binary 0</div><div>3. ‘0’ is Not a Number</div><div>4. Example: 131131 represents binary ‘010010’</div><div>5. All the tokens are either 5 or 6 bits long.</div><div>&nbsp;</div><div>Output Encoding:</div><div>&nbsp;</div><div>The received information is output with the following characteristics:</div><div>1. An 8-bit byte is returned.</div><div>2. The received token is left justified in a binary 8-bit number.</div><div>3. A control sequence in the least-significant bits indicating:</div><div>&nbsp; a. How many of the most-significant bits are in the number.</div><div>&nbsp; b. If it is a 6-bit number, the least significant bit (extra bit) of the 6-</div><div>&nbsp; &nbsp; &nbsp; bits is repeated to improve error detection.</div><div>&nbsp; c. A unique code (‘111’) is returned if the token was Not A Number.</div><div>&nbsp;</div>
