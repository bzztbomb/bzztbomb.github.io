Teensyduino Regression Testomatic, 1st Try...
2013-04-16 05:43:09
paul

<p>Over the last couple weeks I've been working on a automated test system for Teensyduino, which someday will verify nearly all the Arduino functionality on every board and also test most of the Arduino libraries.&nbsp; Here's what my first try looks like.</p><p><img alt="" src="http://www.dorkbotpdx.org/files/images/testomatic1.jpg" style="width: 640px; height: 604px;"></p><p>Click "Read more" for another photo, a bit of discussion about how this works (and what doesn't work so well), and a peek at what will be my second attempt.</p><p><!--break--></p><p>The main idea, which <a href="http://forum.pjrc.com/threads/518-PWM-Frequency-%28was-TimerOne-on-Teensy-3%29?p=2468&amp;viewfull=1#post2468">began in November 2012</a>, behind this test is the use of <a href="http://www.analog.com/en/switchesmultiplexers/analog-crosspoint-switches/ad75019/products/product.html">AD75019 switch matrix chips</a> to allow the control board (on top) to configure which pins on the other 3 boards (the test boards, each with a different Teensy) connect to each other and to various peripheral hardware.</p><p>Here's a peek inside....</p><p><img alt="" src="http://www.dorkbotpdx.org/files/images/testomatic2.jpg" style="width: 640px; height: 491px;"></p><p>The switch matrix chips provide a 16 signal bus.&nbsp; Any pins from any of the test devices and some peripherals on the top board can be connected to any of the 16 signals.</p><p>At first, I started building on the (now abondoned) <a href="https://github.com/arduino/Tests">ArduinoTestSuite project</a> started by Mark Sproul, Matthew Nurdoch, and Rick Anderson.&nbsp; A good number of the tests were ones I wrote and contributed while debugging the Arduino String functions, plus a couple others.&nbsp; Sadly, that code is filled with AVR-centric design that doesn't play nicely with Teensy 3.0.&nbsp; There's a tremendous amount of complex code just for printing stuff, and it's in a <a href="http://en.wikipedia.org/wiki/Hungarian_notation">style I don't like</a> with complex naming conventions for even the simplest things!&nbsp; I ended up pulling out the String and pulseIn test I wrote, and modeled some of my new tests after theirs, but none of the original code has remained.&nbsp; It was just easier to rewrite everything in a much simpler way.&nbsp; But their work was tremendously helpful as a starting point and inspiration for this project.&nbsp; Rick, Mark, Matt... if you're reading this, thanks.&nbsp; :-)</p><p>One of my goals with this design was to create a multi-board test.&nbsp; In ArduinoTestSuite, the paradigm is the code runs on a single board and prints messages about success or failure.&nbsp; For testing something like Tone, this model works pretty well.&nbsp; The tone is created in the background by interrupts, while the main program rapidly polls the signal with digitalRead().&nbsp; The hardware requirement is simple, just 2 pins connected together (or with the switch matrix, those 2 pins both connected to 1 of the 16 bus signals).</p><p>However, the single board approach is pretty limited.&nbsp; For example, testing delay() with <a href="https://github.com/arduino/Tests/blob/master/examples/ATS_Delay/ATS_Delay.ino">this code</a> is pretty pointless.&nbsp; Since delay() and millis() are implemented by the same software, very few types of defects would be detected by this single board test.&nbsp; I wrote a 2-board delay test, where the first board uses digitalWrite() with a delay(), and the second board measures the actual delay with digitalRead() and micros().&nbsp; A future version might use timer hardware for higher accuracy, but even software polling works very well.&nbsp; The test runs twice, once with an AVR-based Teensy 2.0 sending and a ARM-based Teensy 3.0 receiving, and then vise versa.&nbsp; They're different processors and different code bases.... so if a regression happens someday causing delay() to break or become inaccurate, hopefully only 1 will break, or they might break differently, but much better odds of automatically detecting the defect.</p><p>Currently, the control board implements 5 simple text-based commands, a few to configure the switch matrix, one to configure which Teensy is "active" (more on that in a moment), and a command to reboot the active Teensy, which causes it to be reprogrammed.</p><p>So far, the software side on my PC is very simple.&nbsp; I back-ported Arduino 1.5.2's command line inputs to 1.0.4 (any copy of Arduino modified by Teensyduino has this).&nbsp; A makefile just runs Arduino to compile the code.&nbsp; Teensy Loader supports a programming mode where you use Verify in Arduino, which causes the Teensy Loader to update with the freshly compiled code, and the you press the button to reprogram.&nbsp; After Arduino compiles the code, the makefile runs a program to send the commands to the control board, which configure the switch matrix and reboots the Teensy to run the test.&nbsp; Then after a 1 second delay, another program waits for that Teensy to come online, captures its Serial.print() output and parses for a message indicating success or failure.</p><p>Each single board test is 3 components: the .ino program which does the test and prints success or fail (and optionally info as it does the test), the script to send to the control board causing the switch matrix to be configured, the desired test Teensy selected and rebooted, and the makefile to compile, send the script and run the result capture.&nbsp; Each test has its own tiny makefile.&nbsp; A master makefile just runs them all.&nbsp; If any step anywhere fails, make stops the "build".&nbsp; It's all just relatively simple makefiles to compile the code, configure the hardware to start the test, and capture the result.&nbsp; Some day this might integrate with a fancy system like <a href="http://jenkins-ci.org/">Jenkins</a>, but for now I'm focused on just keeping it all very minimal makefile which I continue to develop.</p><p>The active board command selects which of the board will receive all the other commands.&nbsp; It's a very simple system.&nbsp; One key component is a USB disconnect switch.&nbsp; The control board is always connected.&nbsp; Only one of the other boards can connect to USB.&nbsp; I put <a href="http://www.fairchildsemi.com/pf/FS/FSUSB30.html">FSUSB30</a> switches on each board.&nbsp; If you look at the photo above, you'll see a pair of wires soldered from each Teensy's USB to the test board, so the USB goes through those FSUSB30's to allow the control board to connect only the active Teensy.</p><p>The 2-board test was a challenge.&nbsp; It turned out to be somewhat difficult to get the transmitting board, which is programmed and boots up first, to reliably wait until the receiving board is read for the test signals to begin.&nbsp; After much frustration with simple high-low or low-high transitions, I ended up building something that's probably overkill, but works very reliably.&nbsp; A sequence of high-low, low-high transitions is sent with distinctive timing.</p><p>&nbsp;</p><p>void RegressionTestClass::sendSignal(uint8_t pin)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digitalWrite(pin, HIGH);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pinMode(pin, OUTPUT);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digitalWrite(pin, HIGH);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delayMicroseconds(6000);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digitalWrite(pin, LOW);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delayMicroseconds(1700); // 3 distinctive pulse widths, very unlikely<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digitalWrite(pin, HIGH); // to occur randomly while boards reboot<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delayMicroseconds(3900); // or the switch matrix is reconfigured<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digitalWrite(pin, LOW);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delayMicroseconds(4700);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; digitalWrite(pin, HIGH);<br>}<br>&nbsp;</p><p>The receiver waits for this sequence, with some tolerance in the timing, but it must match very closely:</p><p>&nbsp;</p><p>void RegressionTestClass::waitForSignal(uint8_t pin)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elapsedMicros usec;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long t1, t2, t3;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pinMode(pin, INPUT_PULLUP);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (1) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Serial.println("begin waitForSignal");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (digitalRead(pin) == LOW) ; // wait<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (digitalRead(pin) == HIGH) ; // wait<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usec = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (digitalRead(pin) == LOW &amp;&amp; usec &lt; 1850) ; // wait<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1 = usec;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Serial.print("t1=");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Serial.println(t1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (t1 &lt; 1600 || t1 &gt;= 1850) continue;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (digitalRead(pin) == HIGH &amp;&amp; usec &lt; 5900) ; // wait<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t2 = usec;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Serial.print("t2=");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Serial.println(t2);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (t2 &lt; 5500 || t2 &gt;= 5900) continue;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (digitalRead(pin) == LOW &amp;&amp; usec &lt; 11000) ; // wait<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t3 = usec;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Serial.print("t3=");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Serial.println(t3);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (t3 &lt; 10200 || t3 &gt;= 11000) continue;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>}<br>&nbsp;</p><p>With this signalling in place, building the 2-board test became fairly easy.&nbsp; It has 5 components: the 2 .ino files for the sender and receiver, the 2 control board scripts to cause each to be programmed and of course configure the switch matrix to route the signals between the boards, and the makefile to run the commands.</p><p>&nbsp;</p><p>However, as I've worked with this, one pretty serious limitation has come up.&nbsp; The AD75019 switches are about 200 ohms on resistance.&nbsp; I'm powering it with 12 volts.&nbsp; 24 volts apparently gives about 150 ohms, but that's only a small improvement.</p><p>The problem is this design has a lot of capacitance on those 16 shared bus signals.&nbsp; The run through that ribbon cable to every board, and on each board to 2 or 3 of the switch matrix chips.&nbsp; The wires on each board between the Teensy and the switch matrix aren't short either, since the board has places for 3 different Teensy boards, so they add some capacitance.&nbsp; To route any signal between 2 points, it has to go through a 200 ohm switch to one of the bus signals, then through another 200 ohm switch driving a lengthy wire at the destination.</p><p>The result is about 2 MHz bandwidth.&nbsp; That works great for many types of tests, but for SPI-based tests like the Ethernet and SD library, it's a real problem.</p><p>It turns out the Teensy 3.0 test on Ethernet can just barely work, because it's sending 3 volt signals and the W5100 chip is looking for 3 volts.&nbsp; The SCK clock looks pretty terrible... pretty much a triangle wave with curved slopes, but it just barely works.&nbsp; But a 5 volt signal bandwidth limited ends up spending too much time high when received by the 3 volt (but 5V tolerant) ethernet module.&nbsp; I got an Ethernet test to work by configuring the Teensy 2.0 to run at 8 MHz.&nbsp; So far, I haven't been able to make the SD library test work at all.</p><p>Over the last few days I've been considering many other options.&nbsp; I designed a bigger version of this board with a couple old SpartanXL FPGAs I have left over from the ancient MP3 player project (from long before Apple sold their first iPad).&nbsp; Those old FPGAs are 5 volt tolerant, which is important.&nbsp; The board grew in size and had to grow to 4 layers to route, and since this basically adds yet more stuff, it probably increases the capacitance problem even more.&nbsp; I did a preliminary design for a big digital mux similar to the switch matrix, but not bidirectional like the analog switches, really unidirectional 2 ones in the same chip.</p><p>I was about to send this board to fab, but then had a lot of second throughts.&nbsp; One big one was the Xilinx software said the pad-to-pad timing was 20 ns.&nbsp; That's not bad, but this design required the signal to go through 2 of those paths, so 40 ns from the Teensy to the SD card.&nbsp; Then the MISO signal goes through 40 ns to get back.&nbsp; I orginally has reservations about the analog switches being too slow, but I just wanted to get the project started.&nbsp; Now I had this feeling again.....</p><p>So of course I redesigned everything!</p><p>I had a epiphany that a single test system didn't need to cover every possible scenario.&nbsp; Simple, right?&nbsp; Well, I had designed a mostrously complex 4 layer board to add those FPGAs, and even that might not be good enough.&nbsp; So instead, I started work on a fast digital-only board.&nbsp; Rather than make a shared bus that's extremely flexible and expandable, I just went with connecting every pin from the 3 test boards to a FPGA I/O pin.&nbsp; Reconfiguring the FPGA can serve to route the signals.&nbsp; I'm not going to implement a big switch matrix (I did draw up a design... it's a huge monster), but rather keep things extremely simple and do a new FPGA configurations for each test, which will probably be a trivial schematic with just a few buffers connecting one FPGA pin to another.&nbsp; That can get the delay into the 10ns range.</p><p>I also discovered Xilinx made one more generation, the Spartan2, which is 5 volt tolerant.&nbsp; Luckily, they're still readily available.&nbsp; Xilinx has long since dropped support for those chips from their software.&nbsp; The don't publish old versions.&nbsp; But as luck would have it, I still have the original Foundation 3.1 software and even a service pack they published plus a disc with the documentation of that era (none of these things are still available from Xilinx).</p><p>So, here's my next attempt, which was sent to fab yesterday.</p><p><img alt="" src="http://www.dorkbotpdx.org/files/images/testomatic3.gif" style="width: 640px; height: 640px;"></p><p>It's got the 3 Teensy boards with every digital pin connected to a FPGA pin.&nbsp; 12 signals go to 2 different ethernet modules and a SD card, and 17 signals go to header that I'll use to connect other peripherals as I expand my testing to cover more Arduino libraries.</p><p>The key point though, is this high speed digital board is only needed for the tests that can't run on the stack of boards with the more flexible analog switch matrix.&nbsp; The analog switches are really very nice, despite the limited bandwidth, because they're bidirectional and, well, analog.</p><p>Over time, I intend to develop automated tests for all the standard Arduino functionality and probably most of the Arduino <a href="http://www.pjrc.com/teensy/td_libs.html">libraries officially supported on Teensy</a>.&nbsp; That list of libraries will probably double over the next year too, since I have a big box of purchased hardware sitting right here.&nbsp; I plan to start incorporating them into this automated testing as much as I reasonably can.</p><p>Hopefully over the long term, this effort will really improve the code quality of Teensy's support for Arduino usage.&nbsp; It might also really benefit regular Arduino users too.&nbsp; Already with only just 6 tests implemented, I've discovered a couple bugs, one of which appears to also be in Arduino 1.5.2 for Arduino Due.&nbsp; I'm planning to contribute a fix to them soon.</p><p>I'll probably post more here as this system develops.&nbsp; If anyone is interested (or if anyone actually read all this), please let me know in the comments below?&nbsp; Also, before anyone asks about fancy Continuous Integration systems, see my note above about keep this as simple as possible while developing the basic system.</p><p>&nbsp;</p><p>&nbsp;</p>