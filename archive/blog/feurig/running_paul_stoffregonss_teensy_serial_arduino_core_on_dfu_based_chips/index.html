<a href="http://www.flickr.com/photos/7175086@N05/4538349229/"><img class=" alignnone" src="http://farm3.static.flickr.com/2705/4538349229_21ec78bceb.jpg" alt="das blinkin" width="500" height="375" /></a>With a lot of my projects I have done my prototyping with Paul Stoffregon's Teensy series of boards before moving them onto their own codebases. On those occasions where the "prototype was all I needed" I would compile the code using the teensyduino and then manually load the .hex file onto the target. As I am looking at using the arduino for more projects I decided to take a look at how paul interacts with the Arduino IDE and see if I could load code directly onto my chips.<h3>boards.txt</h3>The arduino allows for different chips and configurations through the boards.txt and the programmers.txt files. Each configuration usually will also have a "core" which maps the pins and handles the particulars of that chip. When you run paul's teensyduino installer it adds several entrys to the boards.txt file including the entry below.<pre>teensy_ser.name=Teensy 1.0 (USB Serial)teensy_ser.upload.protocol=halfkayteensy_ser.upload.maximum_size=15872teensy_ser.upload.speed=38400teensy_ser.upload.disable_flushing=trueteensy_ser.upload.avrdude_wrapper=teensy_rebootteensy_ser.build.mcu=at90usb162teensy_ser.build.f_cpu=16000000Lteensy_ser.build.core=teensy_serial...</pre><div><span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace;font-size: small"><span style="line-height: 18px"><span style="font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif;line-height: 19px;font-size: 13px">Looking at pauls additions to the boards.txt I see that he is using the teensy_serial core  that he has written to create a simple usb to serial interface and to map the usb avr pins and other peripherals to the arduino conventions. He is also adds an entry to the arduino uploader class which lets him use a wrapper for avrdude which lets him use his proprietary bootloader. This wrapper is installed by the Paul's installer and  lives in the Arduino's bin directory. After looking to see if this wrapper was a script I replaced the entry in the boards.txt and put a script into the bin directory called "dfume", after seeing that my replacement wrapper worked I added two new entries for each class of avr that I wanted to use the atmega32u2 and the atmega32u4</span></span></span></div><pre>#############################################################fouryou.name = atMega32U4fouryou.upload.protocol=atmega32u4fouryou.upload.maximum_size=32256fouryou.upload.speed=38400fouryou.upload.disable_flushing=truefouryou.upload.avrdude_wrapper=dfumefouryou.build.mcu=atmega32u4fouryou.build.f_cpu=16000000Lfouryou.build.core=teensy_serial#############################################################tooyou.name = atMega32u2tooyou.upload.protocol=atmega32u2tooyou.upload.maximum_size=32256tooyou.upload.speed=38400tooyou.upload.disable_flushing=truetooyou.upload.avrdude_wrapper=dfumetooyou.build.mcu=at90usb162tooyou.build.f_cpu=16000000Ltooyou.build.core=teensy_serial<span style="font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif;font-size: small"><span style="line-height: 19px"></span></span></pre>I started with a blank script that just printed the arguments passed to the wrapper and then called it by restarting my Arduino (to reload the boards.txt) And then selecting one of the new boards and "Uploading" my code. This gave me a window to interactively work through my script. Since the avrdude_wrapper code just pretends to be an avrdude most of the script is munging the arguments passed to avrdude to get the commands to pass to dfu-programmer.<pre>#!/usr/bin/perluse Getopt::Std;print @ARGV;my %args;my $hexfile;my $dfu = "/usr/local/bin/dfu-programmer";my $cpu;my $hexfile;getopt('pUc',\%args);$hexfile=$args{U};$hexfile =~ s/flash:w://;$hexfile =~ s/:i//;$cpu=$args{c};print "\n[" . $hexfile . "]";print "\n[" . $cpu . "]\n";print "$dfu $cpu erase\n";system "$dfu $cpu erase";print "$dfu $cpu flash $hexfile\n";system"$dfu $cpu flash $hexfile";print "$dfu $cpu start\n";system "$dfu $cpu start 1&gt;&amp;2";print "\n";</pre><div><span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace;font-size: small"><span style="line-height: 18px"></span></span></div>There is one tricky bit. The current avr-gcc doesnt support the atmega32u2 correctly but the code for the at90usb162 is binary compatible so the build.mcu is set to the at90usb162. But then dfu-programmer supports the correct chip and wont find the device so we use the fact that the upload.protocol argument is passed directlyalong using the -c argument and everything works fine.So now we just use the hwb and reset buttons to get the system into dfu mode and upload our code directly from the arduino. Its not as slick as the teensy in "auto" mode but it works.<img width=500 src=http://farm3.static.flickr.com/2717/4539212392_6ebd88acc3_o.jpg>
