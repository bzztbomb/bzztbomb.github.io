DMX Lighting Sequence Player
2013-07-01 05:46:05
paul

<p><a href="https://www.facebook.com/PDXCORE2013">Portland CORE effigy at Burning Man</a> will be using DMX controlled lighting this year.&nbsp; At least that's the plan, but a low-cost and low-power way to automatically play the lighting sequence (without a PC) is needed.&nbsp; Here's a little board I made for the purpose.</p><p><img alt="" src="/files/images/dmx_autoplay.jpg" style="width: 640px; height: 461px;"></p><p>Click "Read more" for source code and other technical details.</p><p><!--break--></p><p>First, the lighting sequence is created using <a href="http://www.vixenlights.com/downloads/vixen-2-downloads/">Vixen</a> version 2.&nbsp; Creating the sequence is pretty simple, just click ranges of time slots and use the toolbar buttons to turn the light on, off, fade up, fade down, etc.&nbsp; Vixen has lots of little features to create patterns, but so far I've only used the simplest ones.</p><p>One nice feature of Vixen, which I knew existed but never tried back on the <a href="/blog/paul/hand_eye_supplys_starlight_parade_float_wins_award">Hand-Eye Supply float</a> (Tobias did most of the Vixen stuff) is the Sequence Preview.&nbsp; It takes a photo of your project and then you can define pixels that will overlay the image for each lighting channel.&nbsp; Here's a screenshot:</p><p><img alt="" src="/files/images/vixen2.png" style="width: 639px; height: 675px;"></p><p>Vixen version 3 greatly expands the preview feature and adds lots of new features, but it doesn't use the simple time slots that we need from version 2.&nbsp; Maybe someday I'll revist this project and make a way to use version 3, but for now it's limited to Vixen 2.</p><p>Vixen saves files to its Sequences folder as a ".vix" file.&nbsp; It's XML format, with a big binary dump of the raw sequence data encoded as base64.&nbsp; I started reading about <a href="http://doityourselfchristmas.com/forums/showthread.php?13650-Vixen-FIle-Format">Vixen's file format</a>, determined to write a program to play it.&nbsp; Pretty soon, I found <a href="http://www.billporter.info/2012/10/07/tutorial-vixeno-vixen-sequence-conversion-for-arduino/">Bill Porter had already done it</a>, and written a very nice tutorial.</p><p>I just modified Bill's awesome script.&nbsp; I've done very little with Python before, but it's a pretty easy language to pick up.&nbsp; There are lots of tutorials and great documentation online.&nbsp; But being a Python novice, I probably didn't do everything the best way.&nbsp; At least it works.&nbsp; Actually, it apparently only works with Python 2.7, but not Python version 3.&nbsp; Again, I'm a Python novice....</p><p>It turned out Bill's script could not read a .vix file with the image preview.&nbsp; It finds too many channels, because the channels within the preview get double counted.&nbsp; Bill used Phython's <a href="http://docs.python.org/2/library/xml.dom.minidom.html">minidom</a> XML parser with getElementsByTagName() to find all the channels.&nbsp; I found much better documentation for Python's <a href="http://docs.python.org/2/library/xml.etree.elementtree.html">ElementTree</a>, so I rewrote the script using that to carefully find only the channels in the main section of the file.</p><p>I also changed the script's output.&nbsp; Instead of creating a .cpp file to be compiled directly into Arduino, I had the script output a text file with the data in a format that could easily be read from a SD card.&nbsp; This way, there's no practical limit to the sequence length.&nbsp; The script stores the data in a simple format, so Arduino code can just read each line of the file as it plays the sequence.&nbsp; Here's what the text format looks like:</p><p style="margin-left: 40px;">100<br>000000000000000000000000000000000000FF000000000000000000000000000000000000000000<br>331700000000000000000000000000000000F9000300000000000000000000000000000000000000<br>662E00000000000000000000000000000000F4000600000000000000000000000000000000000000<br>994500000000000000000000000000000000EF000900000000000000000000000000000000000000<br>CC5C0E000000000000000000000000000000EA000C00000000000000000000000000000000000000<br>FF731C000000000000000000000000000000E5001000000000000000000000000000000000000000<br>FF8B2A000000000000000000000000000000E0001300000000000000000000000000000000000000<br>BFA238000000000000000000000000000000DB001600000000000000000000000000000000000000<br>7FB946000000000000000000000000000000D6001900000000000000000000000000000000000000<br>3FD055000000000000000000000000000000D1001C00000000000000000000000000000000000000<br>00E76300000080FF00000000000000000000CB002000000000000000000000000000000000000000<br>00FF710A00007BF605000000000000000000C6002300000000000000000000000000000000000000<br>00FF7F15000077EE0A000000000000000000C1002600000000000000000000000000000000000000</p><p>The first line is the number of milliseconds for each update period.&nbsp; Then each line has channel 1 in the first 2 characters, channel 2 in the next 2 characters, and so on.</p><p>With the data in a simple format, it was pretty easy to write code with Arduino to read it.&nbsp; The DmxSimple library did all the heavy lifting for transmitting DMX, so only a RS-485 chip needs to be connected to get DMX output.</p><p>The SD library and Arduino 1.0's new readBytesUntil() function makes reading the text file pretty easy.&nbsp; Just a little code was needed to turn the hex digits back to binary.&nbsp; I suppose I could have made the Python script output binary, but I felt the text file would be much nicer, so anyone using this project could "see" the data by just double clicking the file.</p><p>With 5 PWM output available (DmxSimple uses Timer2, so 2 of the 7 PWM on Teensy2 aren't usable), I added a tiny bit of code to display the first 5 channels on LEDs.&nbsp; The script can parse up to 256 channels, half of DMX's maximum.&nbsp; I'm pretty sure that will be plenty of this project.</p><p>Here's the Arduino sketch:</p><p style="margin-left: 40px;">&nbsp;</p>
<pre style="margin-left: 40px;">#include&nbsp;&lt;<span style="color: #CC6600;">SD</span>.h&gt;
#include&nbsp;&lt;<span style="color: #CC6600;">DmxSimple</span>.h&gt;

<span style="color: #CC6600;">const</span> <span style="color: #CC6600;">int</span> chipSelect = 0;
<span style="color: #CC6600;">char</span> buffer[516];

<span style="color: #CC6600;">void</span> <span style="color: #CC6600;"><b>setup</b></span>()
{
&nbsp;&nbsp;<span style="color: #CC6600;">for</span> (<span style="color: #CC6600;">int</span> i=0; i&lt;<span style="color: #006699;">NUM_DIGITAL_PINS</span>; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #CC6600;">pinMode</span>(i, <span style="color: #006699;">INPUT_PULLUP</span>);
&nbsp;&nbsp;}
&nbsp;&nbsp;<span style="color: #CC6600;">analogWrite</span>(4, 0);
&nbsp;&nbsp;<span style="color: #CC6600;">analogWrite</span>(5, 0);
&nbsp;&nbsp;<span style="color: #CC6600;">analogWrite</span>(9, 0);
&nbsp;&nbsp;<span style="color: #CC6600;">analogWrite</span>(15, 0);
&nbsp;&nbsp;<span style="color: #CC6600;">analogWrite</span>(14, 0);
&nbsp;&nbsp;<span style="color: #7E7E7E;">//Serial.begin(115200);</span>
&nbsp;&nbsp;<span style="color: #CC6600;">DmxSimple</span>.<span style="color: #CC6600;">usePin</span>(10);
&nbsp;&nbsp;<span style="color: #CC6600;">DmxSimple</span>.<span style="color: #CC6600;">maxChannel</span>(100);
&nbsp;&nbsp;<span style="color: #CC6600;">for</span> (<span style="color: #CC6600;">int</span> i=1; i&lt;=100; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #CC6600;">DmxSimple</span>.<span style="color: #CC6600;">write</span>(i, 0);
&nbsp;&nbsp;}
&nbsp;&nbsp;<span style="color: #7E7E7E;">// initialize the SD card</span>
&nbsp;&nbsp;<span style="color: #CC6600;">pinMode</span>(<span style="color: #006699;">LED_BUILTIN</span>, <span style="color: #006699;">OUTPUT</span>);
&nbsp;&nbsp;<span style="color: #CC6600;">digitalWrite</span>(<span style="color: #006699;">LED_BUILTIN</span>, <span style="color: #006699;">HIGH</span>);
&nbsp;&nbsp;<span style="color: #CC6600;">while</span> (!<span style="color: #CC6600;">SD</span>.<span style="color: #CC6600;">begin</span>(chipSelect)) {
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #CC6600;">delay</span>(250);
&nbsp;&nbsp;}
&nbsp;&nbsp;<span style="color: #CC6600;">digitalWrite</span>(<span style="color: #006699;">LED_BUILTIN</span>, <span style="color: #006699;">LOW</span>);
}

<span style="color: #CC6600;">void</span> <span style="color: #CC6600;"><b>loop</b></span>()
{
&nbsp;&nbsp;play();
&nbsp;&nbsp;<span style="color: #7E7E7E;">// TODO: would be nice to detect if the SD card is removed</span>
&nbsp;&nbsp;<span style="color: #7E7E7E;">// and automatically recover, rather than requiring power cycle</span>
}

<span style="color: #CC6600;">void</span> play()
{
&nbsp;&nbsp;<span style="color: #CC6600;">File</span> f = <span style="color: #CC6600;">SD</span>.<span style="color: #CC6600;">open</span>(<span style="color: #006699;">"COREPLAY.TXT"</span>);
&nbsp;&nbsp;<span style="color: #CC6600;">if</span> (f) {
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #7E7E7E;">// read the period so we know how fast to play</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #CC6600;">long</span> period = f.<span style="color: #CC6600;">parseInt</span>();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #7E7E7E;">//Serial.print("Period is ");</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #7E7E7E;">//Serial.println(period);</span>
&nbsp;&nbsp;&nbsp;&nbsp;f.<span style="color: #CC6600;">readBytesUntil</span>(<span style="color: #006699;">'\n'</span>, buffer, sizeof(buffer));
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #7E7E7E;">// then read every line and play it</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #CC6600;">elapsedMillis</span> msec=0;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #CC6600;">while</span> (f.<span style="color: #CC6600;">available</span>()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.<span style="color: #CC6600;">readBytesUntil</span>(<span style="color: #006699;">'\n'</span>, buffer, sizeof(buffer));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #7E7E7E;">//Serial.print("Data: ");</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #7E7E7E;">//Serial.print(buffer);</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #CC6600;">int</span> channels = hex2bin(buffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #7E7E7E;">//Serial.print(", ");</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #7E7E7E;">//Serial.print(channels);</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #7E7E7E;">//Serial.println(" channels");</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #CC6600;">if</span> (channels &gt; 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #7E7E7E;">//transmit all the channels with DMX</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #CC6600;">DmxSimple</span>.<span style="color: #CC6600;">maxChannel</span>(channels);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #CC6600;">for</span> (<span style="color: #CC6600;">int</span> i=0; i &lt; channels; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #CC6600;">DmxSimple</span>.<span style="color: #CC6600;">write</span>(i+1, buffer[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #7E7E7E;">// display the first 5 channels on LEDs</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #CC6600;">analogWrite</span>(4, buffer[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #CC6600;">analogWrite</span>(5, buffer[1]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #CC6600;">analogWrite</span>(9, buffer[2]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #CC6600;">analogWrite</span>(15, buffer[3]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #CC6600;">analogWrite</span>(14, buffer[4]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #7E7E7E;">// wait for the required period</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #CC6600;">while</span> (msec &lt; period) ; <span style="color: #7E7E7E;">// wait</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msec&nbsp;=&nbsp;msec&nbsp;-&nbsp;period;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;f.<span style="color: #CC6600;">close</span>();
&nbsp;&nbsp;}
}


<span style="color: #CC6600;">byte</span> hexdigit(<span style="color: #CC6600;">char</span> c)
{
&nbsp;&nbsp;<span style="color: #CC6600;">if</span> (c &gt;= <span style="color: #006699;">'0'</span> &amp;&amp; c &lt;= <span style="color: #006699;">'9'</span>) <span style="color: #CC6600;">return</span> c - <span style="color: #006699;">'0'</span>;
&nbsp;&nbsp;<span style="color: #CC6600;">if</span> (c &gt;= <span style="color: #006699;">'A'</span> &amp;&amp; c &lt;= <span style="color: #006699;">'F'</span>) <span style="color: #CC6600;">return</span> c - <span style="color: #006699;">'A'</span> + 10;
&nbsp;&nbsp;<span style="color: #CC6600;">return</span> 255;
}


<span style="color: #CC6600;">int</span> hex2bin(<span style="color: #CC6600;">char</span> *buf)
{
&nbsp;&nbsp;<span style="color: #CC6600;">byte</span> b1, b2;
&nbsp;&nbsp;<span style="color: #CC6600;">int</span> i=0, count=0;
&nbsp;&nbsp;
&nbsp;&nbsp;<span style="color: #CC6600;">while</span> (1) {
&nbsp;&nbsp;&nbsp;&nbsp;b1&nbsp;=&nbsp;hexdigit(buf[i++]);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #CC6600;">if</span> (b1 &gt; 15) <span style="color: #CC6600;">break</span>;
&nbsp;&nbsp;&nbsp;&nbsp;b2&nbsp;=&nbsp;hexdigit(buf[i++]);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #CC6600;">if</span> (b2 &gt; 15) <span style="color: #CC6600;">break</span>;
&nbsp;&nbsp;&nbsp;&nbsp;buf[count++]&nbsp;=&nbsp;b1&nbsp;*&nbsp;16&nbsp;+&nbsp;b2;
&nbsp;&nbsp;}
&nbsp;&nbsp;<span style="color: #CC6600;">return</span> count;
}
</pre>
<p>I'm not actually going to Burning Man this year.&nbsp; So far, my success rate for building stuff for burners to take and use on the Playa (in my absence) has been pretty low.&nbsp; Burning Man is a really harsh environment and it's also filled will all sorts of distractions when solving any sort of technical problems.&nbsp; This year the team has someone who's very good with electronics and he seems comfortable with Python.&nbsp; Hopefully this little device will be usable and they'll be able to create sequences, convert the file and get it onto the SD card.</p><p>EDIT: Here's an image from Jesse doing a test with all the DMX lights.</p><p><img alt="" src="/files/images/1070107_10200716943743249_1434246947_n.jpg" style="width: 960px; height: 717px;"></p><p><br>EDIT: I built a spare board.&nbsp; They wanted it to be able to play multiple files and randomly choose them, so I added a LCD to show which file is playing.&nbsp; Hopefully will make troubleshooting easier.</p><p><img alt="" src="/files/images/spare_board.jpg" style="width: 640px; height: 640px;"></p><p>Here's the Python script and revised Arduino code (with randomized multi-file playing and display), in case anyone ever wants to use this controller for their own DMX controlled lighting.</p><p>&nbsp;</p>