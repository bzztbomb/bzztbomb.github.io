<head>
  <title>Better SPI Bus Design in 3 Steps</title>
  <link rel="stylesheet" href="/css/archive.css">
</head>

<body>
  <div id="db-header"></div>
  <h1 class="db-page-header">Better SPI Bus Design in 3 Steps</h1>
  <h2 class="db-page-header">By: paul</h2>
  <h3 class="db-page-header">2014-11-24 17:11:56</h3>

  <div id="db-content">
    <p>Most Arduino SPI tutorials show this simple but poor SPI bus design:</p><p><img alt="" src="/files/images/spi_diagram_poor.png" style="width: 640px; height: 432px;"></p><p>A much better SPI bus design can prevent conflicts.&nbsp; 3 simple improvements are needed:</p><ol><li><h3>Use pullup resistors on all chip select signals.</h3></li><li><h3>Verify tri-state behavior on MISO: use a tri-state buffer chip if necessary.</h3></li><li><h3>Protect bus access with SPI.beginTransaction(settings) and SPI.endTransaction().</h3></li></ol><p><img alt="" src="/files/images/spi_diagram_good.png" style="width: 640px; height: 432px;"></p><p>Click "Read more" for details on these 3 steps.</p><p><!--break--></p><h2>Step 1: Pullup Resistors for Chip Select &amp; Reset Signals</h2><p>When multiple SPI devices are used, and especially when each is supported by its own library, pullup resistors are needed on the chip select pins.</p><p>Without a pullup resistor, the second device can "hear" and respond to the communication taking place on the first device, if that second device's chip select pin is not pulled up.&nbsp; This is easy to understand in hindsight, but it can be temendously confusing and frustrating to novice Arduino users who purchase shields or breakout boards without pullup resistors.&nbsp; Each SPI device works when used alone, but they sometimes mysteriously fail when used together, only because both devices are hearing communication meant to initialize only the first device!</p><p>A simpe workaround for devices without pullup resistor involves adding code at the beginning of setup.</p><pre>    void setup() {      pinMode(4, OUTPUT);      digitalWrite(4, HIGH);      pinMode(10, OUTPUT);      digitalWrite(10, HIGH);      delay(1);      // now it's safe to use SD.begin(4) and Ethernet.begin()    }</pre><p>&nbsp;</p><h2>Step 2: Proper MISO Tri-State Behavior</h2><p>Most SPI chips will tri-state (effectively disconnect) their MISO pin when their chip select signal is high (inactive).</p><p>However, some chips do not have proper MISO tri-state behavior.&nbsp; Fortunately, checking MISO tri-state is easy, especially when prototyping on a breadboard.&nbsp; Just connect two 10K resistors to the MISO line, like this:</p><p><img alt="" src="/files/images/spi_diagram_bias.png" style="width: 640px; height: 432px;"></p><p>When all SPI chips are disabled, the MISO signal should "float" to approximately half the Vcc voltage.&nbsp; If any device is still driving the MISO line, you'll see a logic high (usually close to 3.3V or 5.0V) or logic low (close to zero volts).&nbsp; This test is so easy, it should always be performed by designers of Arduino compatible products.</p><p>Arduino shields and breakout boards with poorly-behaved chips should always include a tri-state buffer.&nbsp; Adafruit's CC3000 breakout board is a good example:</p><p><img alt="" src="/files/images/adafruit_cc3000_buffer.png" style="width: 400px; height: 532px;"></p><p>&nbsp;</p><h2>Step 3: USB SPI Transactions in Software</h2><p>Newer versions of Arduino's SPI library support transactions.&nbsp; Transactions give you 2 benefits:</p><ul><li>Your SPI settings are used, even if other devices use different settings</li><li>Your device gains exclusive use of the SPI bus.&nbsp; Others will not disturb you.</li></ul><p>These improvements solve software conflicts, allowing multiple SPI devices to properly share the SPI bus.</p><p>A typical use of transactions looks like this:</p><pre>    SPI.beginTransaction(SPISettings(14000000, MSBFIRST, SPI_MODE0));    digitalWrite(chipSelectPin, LOW);    SPI.transfer(mybyte1);    SPI.transfer(mybyte2);    digitalWrite(chipSelectPin, HIGH);    SPI.endTransaction();</pre><p>SPI.beginTransaction() takes a special SPISettings variable, which give the maximum clock speed, the data order, and clock polarity mode.&nbsp; The speed is give as an ordinary number, expressing the maximum clock speed that device can use.&nbsp; The SPI library will automatically select the fastest clock available which is equal or less than your number.&nbsp; This allows your code to always use the best speed, even on board with different clock speeds.</p><p>If your code will ever call SPI library functions from within an interrupt (eg, from attachInterrupt), you must call SPI.usingInterrupt().&nbsp; For example:</p><pre>    SPI.begin();    SPI.usingInterrupt(digitalPinToInterrupt(mypin));    attachInterrupt(digitalPinToInterrupt(mypin), myFunction, LOW);</pre><p>If you are developing a library that must be compatible with older versions of Arduino, which lack these SPI transaction functions, you can use SPI_HAS_TRANSACTION to check for the new version.&nbsp; For example:</p><pre>    #ifdef SPI_HAS_TRANSACTION    SPI.beginTransaction(SPISettings(2000000, LSBFIRST, SPI_MODE1));    #endif</pre><p>&nbsp;</p><h2>Please Share and Use This Information</h2><p>Today many SPI-based products for Arduino do not work well together.&nbsp; My hope is this information can help all makers of Arduino compatible devices to achieve much better compatibility.</p><p>Long-term, sharing of knowledge is needed.&nbsp; Please share this information and ask makers of SPI devices and libraries to consider these suggestions.</p><p>This article may be shared and copied under the terms of the <a href="http://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>.&nbsp; Please, copy &amp; share!&nbsp; :-)</p><p><img alt="" src="/files/images/cc88x31.png" style="width: 88px; height: 31px;"></p><p>&nbsp;</p><p>&nbsp;</p>
  </div>

  <div id="db-back-to-index">
    <a href="/archive/index.html">Back to archive index</a>
  </div>
</body>
