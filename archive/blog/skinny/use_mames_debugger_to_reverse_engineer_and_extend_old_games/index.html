<head>
  <title>Use MAME's debugger to reverse engineer and extend old games</title>
  <link rel="stylesheet" href="/css/archive.css">
</head>

<body>
  <div id="db-header"></div>
  <h1 class="db-page-header">Use MAME's debugger to reverse engineer and extend old games</h1>
  <h2 class="db-page-header">By: skinny</h2>
  <h3 class="db-page-header">2013-03-25 15:38:08</h3>

  <div id="db-content">
    <hr><p>Use MAME's debugger to reverse engineer and extend old games</p><p>For the <a href="http://churchofrobotron.com">Church of Robotron</a>'s installation at Toorcamp 2012, we needed to be able to trigger physical events when game events happened in Robotron 2084. A quick summary for context:</p><ul><li>We had an Altar that contained a Linux box that ran <a href="http://www.mame.net/">MAME</a> and <a href="http://en.wikipedia.org/wiki/Robotron:_2084">Robotron 2084</a></li><li>We had joysticks that acted as HID devices</li><li>Player would kneal down and play the game. As events happened in the game (player death, human death, lasers firing), we would trigger physical events.</li></ul><p>We choose to use MAME's debugger to detect game events and notify other pieces of software when they happened. This is a quick tutorial for others (and a reminder to ourselves) if you're interested in doing similar things. We're going to find out how to detect player death!</p><p><img alt="" src="http://bzztbomb.com/images/mame_post-00.png" style="width: 320px; height: 200px;"></p><p><!--break--></p><h2>Prereqs:</h2><ul><li><a href="http://www.mame.net/">MAME</a></li><li>Robotron ROMs</li><li>Patience</li></ul><h2>Here we go!</h2><p>Start mame in windowed mode with the debugger active:</p><p><code>mame -window -debug robotron </code></p><p>You'll see two windows appear, one is the emulation, the other is the debugger window. You can type "help" at the console and get good documentation on the debugger capabilities. You can also click on the down arrow to access a menu that allows you to run the emulation and later pause it at different points.</p><p><img height="313" src="http://bzztbomb.com/images/mame_post-00.png" width="500"></p><h2>Memory dump</h2><p>The first thing to do to find the memory location of the number of lives the player currently has. One way to do this is to take advantage of other peoples work. ;) <a href="http://www.seanriddle.net/">Sean Riddle</a> has a great site with a lot of this <a href="http://seanriddle.com/roboo.dat">information</a> already available! The other way is the manual way. Let's do that!</p><ul><li>Start the game by hitting F5</li><li>Start playing a game, by hitting 5 to drop a coin, and 1 for one player game.</li><li>Pause the game by hitting F8</li><li>In the debugger console, type "Help Memory"</li><li>Ah, nice, there's a dump program memory command. Type: "dump lives3.txt,0,0xFFFF"</li><li>Press F5, then click on the emulation screen</li><li>Hit F2 to access the Operator Screens of Robotron.</li><li>Hit F2 until you see "Game Adjustment"</li><li>We're going to change the default number of lives to 5 and see if we can find the difference in the dump.</li><li>Press "D" to go down to "Turns Per Player"</li><li>Press "I" to change the number of lives to "5"</li><li>Press F2</li><li>Reselect the debugger screen</li><li>Press F8 to pause</li><li>Press the Down Arrow, Select Reset, then Hard</li><li>Start playing a game, by hitting 5 to drop a coin, and 1 for one player game.</li><li>Let the game get to the main screen, then pause the game by hitting F8</li><li>Type "dump lives5.txt,0,0xFFFF"</li></ul><p>Now we have dumps of the game with 5 lives and 3 lives as the default. Let's use a diff tool to see what changed in memory! On OSX, you can use Filemerge or standard old "diff". Scanning through the differences, we don't see anything that correlates to 5 lives and 3 lives. But we do see two spots that seem to correlate to 4 and 2 lives:</p><pre>2722,2727c2722,2727</pre><p>&nbsp;</p><p>AA60: 18 07 FF 06 5F 04 1D AA 58 39 CD 02 00 00 00 00 ...._...X9...... AA60: 18 07 FF 06 43 03 E9 AA 58 39 CD 04 00 00 00 00 ....C...X9......</p><p>This address is AA6B.</p><pre>3039c3039BDE0:  00 00 00 00 00 00 01 00 00 02 50 00 02 01 14 0A  ..........P.....BDE0:  00 00 00 00 00 00 01 00 00 02 50 00 04 01 14 0A  ..........P.....</pre><p>This address is BDEC.</p><h2>Setting watchpoints</h2><p>Let's see if we can test our guesses!</p><p>Go back to the debugger:</p><ul><li>Type "help watchpoints", a Watchpoint will cause program execution to stop whenever a memory address is written to or read from.</li><li>Find out more info on setting a watchpoint by typing "help wpset"</li><li>Let's set our watchpoints</li><li>Type "wpset 0xAA6B,1,w" This will set a watchpoint that is triggered whenever our first memory address guess is written to</li><li>Type "wpset 0xBDEC,1,w"</li><li>Run the game</li><li>Assuming you didn't die, you'll notice the first watchpoint has been hit and it doesn't have anything to do with player death. Lets clear that one.</li><li>Type "wpclear 1"</li><li>Start the game again, and play hard until the Mutant Savior dies.</li><li>You'll notice the second watchpoint is triggered!<p>&nbsp;</p></li></ul><p>We've found the memory location for player lives! We can also take note of the instruction pointer address. It's at 27AC, let's set a breakpoint here.</p><h2>Setting breakpoints</h2><ul><li>Type "bpset 0x27AC"</li><li>Type "wpclear"</li></ul><p>Continue playing. You'll notice the breakpoint is hit for every player death except the last one. That's a bummer! Let's walk up the stack and figure out a better spot. On some CPU types, you can do just that, but with the 6809 that's powering Robotron you can't. So we'll turn the trace file, run the game until we hit our breakpoint, and then close everything. We can step back up from the bottom of the file and see if there are interesting addresses to set breakpoints on.</p><h2>Trace file</h2><ul><li>Type "trace trace.txt"</li><li>Start a game and die</li><li>In the debugger type "traceflush"</li><li>Then type "trace off"</li></ul><p>Open the trace.txt file in an editor. Go all the way to the bottom. You'll see a nice trace with repeated blocks called out. I use these blocks as starting points for new breakpoints. If you scan up the file, you'll see repeated addresses of DC56. Skip above those, they're not interesting. We want to find the first branch of code that doesn't repeat. Just scanning here are the addresses that seem interesting to me:</p><p>0xD676, 0xD8BC, 0xD1ED, 0x30FE</p><p>Let's set some breakpoints:</p><ul><li>Type "bpset 0xD676"</li><li>Type "bpset 0xD8BC"</li><li>Type "bpset 0xD1ED"</li><li>Type "bpset 0x30FE"</li></ul><p>Start running!</p><p>You'll notice D1ED gets triggered alot, so disable that one with the "bpclear (breakpoint number)" The same thing happens to D8BC and D676. But, 0x30FE seems to work!</p><h2>Summary</h2><p>I hope this helps people get used to the MAME debugger. After you have this information, you may want to do something with it. We choose to broadcast game events over UDP. You can see how by looking at our Github repo <a href="https://github.com/breedx2/mcor/tree/master/mamehack">here</a>.</p><p>PRAISE THE MUTANT SAVIOR!</p><p>Crossposted from <a href="http://bzztbomb.com/blog/2013/03/23/use-mames-debugger-to-reverse-engineer-and-extend-old-games/">here</a>.</p>
  </div>

  <div id="db-back-to-index">
    <a href="/archive/index.html">Back to archive index</a>
  </div>
</body>
