<head>
  <title>Display & SPI Optimization</title>
  <link rel="stylesheet" href="/css/archive.css">
</head>

<body>
  <div id="db-header"></div>
  <h1 class="db-page-header">Display & SPI Optimization</h1>
  <h2 class="db-page-header">By: paul</h2>
  <h3 class="db-page-header">2014-08-13 18:58:51</h3>

  <div id="db-content">
    <p>Recently I've been working on an <a href="https://github.com/PaulStoffregen/ILI9341_t3">optimized ILI9341 display library</a>, to take advantage of Teensy 3.1's more capable SPI hardware.&nbsp; Here's a quick video demo, so you can see how much of a difference it makes.</p><p><object height="360" width="640"><param name="movie" value="//www.youtube-nocookie.com/v/tioOB3Ysz70?hl=en_US&amp;version=3&amp;rel=0"><param name="allowFullScreen" value="true"><param name="allowscriptaccess" value="always"><embed allowfullscreen="true" allowscriptaccess="always" src="//www.youtube-nocookie.com/v/tioOB3Ysz70?hl=en_US&amp;version=3&amp;rel=0" type="application/x-shockwave-flash" height="360" width="640"></object></p><p>In the transition from 8 to 32 bit microcontrollers, on-chip SPI ports usually gain more sophisticated features.&nbsp; Special programming is needed to fully levergage these more powerful features.&nbsp; Merely recompiling code designed for simple SPI hardware on 8 bit hardware rarely acheives the best performance.&nbsp; As you can see in the video, optimizing for these features makes a pretty dramatic improvement.</p><p>Click "Read more" for the all the technical details...</p><p><!--break--></p><h2>Fast SPI Clock &amp; 32 Bit ARM</h2><p>Some of the speed increase comes from the simple fact that Teensy 3.1 is based on a Freescale Kinetis chip with 32 bit ARM Cortex-M4 processor, which is significantly faster than the Atmel 8 bit AVR on Arduino Uno.&nbsp; Uno's maximum SPI clock speed is 8 MHz, whereas Teensy's SPI clock can go up to 24 MHz.</p><p>However, faster clocks, without the special optimizations described in the rest of this article, only provide modest speed increase.&nbsp; Only special code to fully leverage the more sophisticated SPI hardware, together with a faster CPU, can give the massive speed increase shown in the video.</p><h2>&nbsp;</h2><h2>SPI FIFO Buffering</h2><p>The 4 word FIFO in Teensy 3.1's SPI port is the key to improving overall SPI throughput.&nbsp; Without the FIFO, software must wait for the SPI hardware to finish transmitting before it can write new data.&nbsp; In principle, the software could begin working on the next byte while the priot byte transmits, but in practice that is very difficult to achieve in the software design.</p><p>When writing to the SPI port on 8 bit AVR, the code waits for each byte to be fully transmitted on the MOSI pin, and it returns the bits received on the MISO pin.&nbsp; This results in very simple and easily maintainable source code, but it results in long gaps between bytes on the SPI bus.</p><p>Here are the SPI signals for the Arduino Uno.&nbsp; Even though the SPI port uses an 8 MHz clock, less than half of the available bus time is actually used, due to significant software overhead.</p><p><img alt="" src="/files/images/scope1.png" style="width: 658px; height: 540px;"></p><p>On Teensy 3.1, using a Freescale Kinetis K20, the SPI port has a 4 word FIFO.&nbsp; In most cases, 4 words is enough buffering to allow for the software overhead to compute more data to occur while previously written words are still transmitting.</p><p>As you can see in these waveforms, only a small gap is present between each word, limited only by the SPI port's timing.&nbsp; The SPI bus is nearly fully utilized, and of course the clock speed is higher (this screenshot is on a 4X faster time scale).</p><p><img alt="" src="/files/images/scope2.png" style="width: 658px; height: 540px;"></p><p>Actually using the SPI FIFO is a task more easily said than actually done.&nbsp; Several approaches were attempted throughout the development of these display optimizations.</p><p>Often when writing to hardware registers, a status bit or flag is read to check if the hardware is ready to receive data, and then then the actual data is written.&nbsp; However, that approach adds significant overhead when the hardware is ready, with the FIFO empty and the SPI bus idle.</p><p>A "write first, ask questions later" technique used in this display optimization always leaves at least 1 word of space available in the FIFO, which allows new data to always be written as quickly as possible.&nbsp; Then the FIFO is checked for full status and the code waits until at least 1 word is free.</p><pre>        void writecommand_cont(uint8_t c) __attribute__((always_inline)) {                <strong>// write first</strong>                SPI0.PUSHR = c | (pcs_command &lt;&lt; 16) | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT;                <strong>// ask questions later</strong>                waitFifoNotFull();        }</pre><p>Using only 3 of the 4 words in the FIFO turns out to be a good trade-off, because it always slightly accelerates the commonly occuring case of a new drawing operation writing its first data to the empty FIFO.&nbsp; 3 words of buffering is usually enough to sustain maximum speed data flow.</p><p>A challange to use the SPI FIFO for this application, writing as rapidly as possible to MOSI while disregard all incoming data from MISO, is properly balancing read with writes, so extra data isn't left in the receive FIFO.&nbsp; I must confess, it took a few iteration on this latest, most optimized code to get it right.&nbsp; It's quite a bit more difficult that the simple but slow approach where you always write and then read a single byte.</p><h2>&nbsp;</h2><h2>16 Bit SPI Transfers</h2><p>The SPI port requires a small idle time between words, even when another word is waiting in the FIFO.&nbsp; Words up to 16 bits are supported.&nbsp; When 8 bytes need to be sent, they can be combined into a 16 bit word to avoid the idle time.</p><p>In this screenshot, 5 bytes are transmitted, but only 3 SPI idle times are needed because 4 of them are send using two 16 bit writes.</p><p><img alt="" src="/files/images/scope3.png" style="width: 658px; height: 540px;"></p><p>Much of the display data is 16 bits, such as X and Y coordinates and 5/6/5 color values.&nbsp; The 16 bit words occupy only a single entry in the SPI FIFO, so 16 bit writes also entend the time allowed for software to generate more data without the SPI bus going idle.</p><h2>&nbsp;</h2><h2>Hardware Control of Register Address &amp; Chip Select</h2><p>On 8 bit AVR processors, the chip select signal needs to be created by manipulating a GPIO pin.&nbsp; For example, the AVR code running on Arduino Uno in the video demo uses this:</p><pre>      void Adafruit_ILI9341::writecommand(uint8_t c) {        *dcport &amp;=  ~dcpinmask;        *csport &amp;= ~cspinmask;        spiwrite(c);        *csport |= cspinmask;      }</pre><p>These extra writes to GPIO registers add overhead.&nbsp; They also require waiting for all 8 bits to full transmit, which greatly increases the difficulty of attempting to do any work while the SPI port is sending a byte.&nbsp; For complex libraries, like color graphical displays, structured programming and maintainable code usually a preferred over "spagetthi code" which might try to perform different tasks during the very short time needed to transmit 1 byte.</p><p>Fortunately, Teensy 3.1's SPI port can control up to 5 "chip select" lines.&nbsp; Two of them are used to control the chip select and data/command address line.&nbsp; The result is virtually zero extra overhead to manipulate these 2 pins.</p><p><img alt="" src="/files/images/scope4.png" style="width: 658px; height: 540px;"></p><p>Each word in the SPI FIFO also has 5 bits for the 5 possible signals.&nbsp; This allows the display software to write commands and data into the FIFO, without waiting.&nbsp; At the SPI port uses the FIFO contents, it automatically controls both the chip select and the data/command address line.&nbsp; As you can see in this screenshot, in most cases command and data are transmitted to the display with only the minimum SPI idle time between each word.</p><p>However, controlling these signals does come with a cost in software complexity.&nbsp; Each write to the SPI port must also have a bit that tells the SPI peripheral whether to continue asserting the signals, or to de-assert them when the write is completed.&nbsp; This means the last write in a group must be done differently, requiring loops to be restructured so the last iteration calls the non-continue SPI write.</p><p>&nbsp;</p><h2>Display Window Addressing</h2><p>Other optimizations have been added to the code, which might help on 8 bit AVR processors, but are dramatically more effective with the faster 32 bit ARM processor and FIFO-based SPI hardware.</p><p>For example, there is the simple diagonal line drawing code.</p><pre>        for (; x0&lt;=x1; x0++) {          if (steep) {            drawPixel(y0, x0, color);          } else {            drawPixel(x0, y0, color);          }          err -= dy;          if (err &lt; 0) {            y0 += ystep;            err += dx;          }        }</pre><p>The drawPixel() function requires 11 bytes of SPI communication to set up the ILI9341 address window, then 2 bytes to actually write the color to the pixel.</p><p>This optimized version combines groups of horizontally or vertically adjacent pixels into a single operation, which requires 11 bytes for the entire line, and then 2 bytes per pixel.&nbsp; Any line at an angle other than 45 degrees involves at least some 2+ pixel segments.&nbsp; Because the ARM processor is fast and can do all this 16 bit integer math in single-cycle operations, and because the SPI FIFO is capable of buffering typically 5 or 6 bytes of prior output, this extra work to avoid the 11 byte address window setup rarely results in SPI idle time.</p><pre>        int16_t xbegin = x0;        if (steep) {                for (; x0&lt;=x1; x0++) {                        err -= dy;                        if (err &lt; 0) {                                int16_t len = x0 - xbegin;                                if (len) {                                        VLine(y0, xbegin, len + 1, color);                                } else {                                        Pixel(y0, x0, color);                                }                                xbegin = x0 + 1;                                y0 += ystep;                                err += dx;                        }                }                if (x0 &gt; xbegin + 1) {                        VLine(y0, xbegin, x0 - xbegin, color);                }</pre><p>Another optimization uses here is inline coding of the Pixel(), VLine() and HLine() functions.&nbsp; These are designed to continue form write, keeping the signals asserted and making best possible use of the FIFO, until the entire line is drawn.&nbsp; Use of these special inline functions in drawLine() and other functions does increase the compiled code size, typically by about 5K to 8K.&nbsp; On Teensy 3.1, where the flash memory is 256K, an extra 5K to 8K is usually a good trade-off for a significant speed boost.&nbsp; But on Arduino Uno, where only 30K of flash is available for code and nearly 20K is already used, these types of optimizations that increase code size aren't usually viewed favorably.</p><p>&nbsp;</p><h2>Future Work on Large Fonts</h2><p>In a future version, I hope to implement arbitrary size bitmap fonts, with support for fast drawing of very large characters.&nbsp; The existing library only supports a single 5x7 font, with simple scaling, which looks quite blocky when scaled up to easily readable sizes on these small displays.</p><p><img alt="" src="/files/images/font.jpg" style="width: 576px; height: 434px;"></p><p>A large 50 to 90 pixel bitmap will look wonderful on these displays.&nbsp; Here is a <a href="http://forum.pjrc.com/threads/26305-Highly-optimized-ILI9341-%28320x240-TFT-color-display%29-library?p=52245&amp;viewfull=1#post52245">lengthy message with my plans for supporting fast &amp; large bitmap fonts</a>.&nbsp; I'm really hoping someone with an interest in Python or other scripting languages might get involved in the project, to convert fonts into a special list-of-blocks format.</p><p>&nbsp;</p><h2>Credit Where Credit Is Due</h2><p>All of this work is based on the open source libraries published by <a href="https://www.adafruit.com">Adafruit Industries</a>.&nbsp; Limor Fried and Kevin Townsend have put a tremendous amount of work into Adafruit's many display libraries.&nbsp; I highly recommend buying Adafruit products to support their efforts.</p><p>Peter Loveday wrote the <a href="http://forum.pjrc.com/threads/15576-Teensy3-ST7735-Library">earliest optimizations for these libraries</a> on Teensy 3.0.&nbsp; My work on these optimizations continued on the path Peter started.&nbsp; Kurt <span class="c1">Eckhardt was the first to <a href="http://forum.pjrc.com/threads/25718-Adafruit-2-8-quot-TFT-Touch-Shield-for-Arduino-for-Teensy-3-1?p=48458&amp;viewfull=1#post48458">port these optimizations to the ILI9341</a> chip.</span>&nbsp; I've since redesigned much of the code.</p><p>&nbsp;</p><p>&nbsp;</p>
  </div>

  <div id="db-back-to-index">
    <a href="/archive/index.html">Back to archive index</a>
  </div>
</body>
